{"version":3,"sources":["testdouble/cljs/csv.cljs"],"mappings":"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","names":["testdouble.cljs.csv/escape-quotes","s","clojure.string/replace","testdouble.cljs.csv/wrap-in-quotes","testdouble.cljs.csv/separate","data","separator","quote?","clojure.string.join","G__43696","cljs.core.map","cljs.core/str","testdouble.cljs.csv/write-data","newline","p1__43697#","testdouble.cljs.csv/newlines","testdouble.cljs.csv/newline-error-message","cljs.core/keys","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","testdouble.cljs.csv/write-csv","seq43698","G__43699","cljs.core/first","cljs.core/next","self__4851__auto__","options","map__43700","cljs.core/--destructure-map","cljs.core.get","temp__5751__auto__","newline-char","js/Error","p__43701","map__43702","testdouble.cljs.csv/-advance","chars","state","cljs.core.assoc","cljs.core/rest","p__43703","map__43704","testdouble.cljs.csv/-consume","char","cljs.core.update","p__43705","map__43706","testdouble.cljs.csv/-end-field","field-buffer","row","cljs.core.conj","testdouble.cljs.csv/-end-row","map__43707","cljs.core/conj","testdouble.cljs.csv/-init-read","cljs.core/seq","testdouble.cljs.csv/read-csv","seq43708","G__43709","map__43710","cljs.core/contains?","G__43712","map__43713","map__43715","in-quoted-field","cljs.core/not","cljs.core._EQ_","cljs.core.dissoc"],"sourcesContent":["(ns testdouble.cljs.csv\n  (:require [clojure.string :as str]))\n\n(defn- escape-quotes [s]\n  (str/replace s \"\\\"\" \"\\\"\\\"\"))\n\n(defn- wrap-in-quotes [s]\n  (str \"\\\"\" (escape-quotes s) \"\\\"\"))\n\n(defn- separate [data separator quote?]\n  (str/join separator\n            (cond->> data\n              :always (map str)\n              quote? (map wrap-in-quotes))))\n\n(defn- write-data [data separator newline quote?]\n  (str/join newline (map #(separate % separator quote?) data)))\n\n(def ^:private newlines\n  {:lf \"\\n\" :cr+lf \"\\r\\n\"})\n\n(def ^:private newline-error-message\n  (str \":newline must be one of [\" (str/join \",\" (keys newlines)) \"]\"))\n\n(defn write-csv\n  \"Writes data to String in CSV-format.\n  Accepts the following options:\n  :separator - field separator\n               (default ,)\n  :newline   - line separator\n               (accepts :lf or :cr+lf)\n               (default :lf)\n  :quote?    - wrap in quotes\n               (default false)\"\n\n  {:arglists '([data] [data & options]) :added \"0.1.0\"}\n  [data & options]\n  (let [{:keys [separator newline quote?] :or {separator \",\" newline :lf quote? false}} options]\n    (if-let [newline-char (get newlines newline)]\n      (write-data data\n                  separator\n                  newline-char\n                  quote?)\n      (throw (js/Error. newline-error-message)))))\n\n(defn- -advance\n  \"Move to the next character.\"\n  [{:keys [chars] :as state}]\n  (assoc state\n         :char  (first chars)\n         :chars (rest chars)))\n\n(defn- -consume\n  \"Append the current character onto the field. Advances.\"\n  [{:keys [char] :as state}]\n  (-> state\n      (update :field-buffer str char)\n      (-advance)))\n\n(defn- -end-field\n  \"Finalize the field, adding it to the current row. Does not advance.\n\n  Following convention, a field that hasn't had any chars appended appears as an\n  empty string, not nil.\"\n  [{:keys [field-buffer row] :as state}]\n  (assoc state\n         :field-buffer nil\n         :row (conj row (str field-buffer))))\n\n(defn- -end-row\n  \"Finalize the last field in the row. Then append the row to the collection of\n  all rows, and start a new row. Does not advance.\"\n  [state]\n  (let [{:keys [row] :as state} (-end-field state)]\n    (-> state\n        (update :rows conj row)\n        (assoc :row []))))\n\n(defn- -init-read\n  \"Prepare to process the string `data`. Advances to the first character.\"\n  [data]\n  (-advance {:chars        (seq data)\n             :field-buffer nil\n             :row          []\n             :rows         []}))\n\n(defn read-csv\n  \"Reads data from String in CSV-format.\"\n  {:arglists '([data] [data & options]) :added \"0.3.0\"}\n  [data & options]\n  (let [{:keys [separator newline] :or {separator \",\" newline :lf}} options\n        ;; convert separator from string to character\n        separator (first separator)]\n    (when-not (contains? newlines newline)\n      (throw (js/Error. newline-error-message)))\n    (loop [{:keys [char chars in-quoted-field field-buffer] :as state} (-init-read data)]\n      (if-not char\n        (:rows (-end-row state))\n        ;; NOTE: always advance or consume to avoid infinite loops\n        (recur (if in-quoted-field\n                 (if (= char \\\")\n                   (if (= (first chars) \\\")\n                     ;; pair of double quotes: use one \"escaped\" quote and drop\n                     ;; the other, staying in quoted field\n                     (-> state (-consume) (-advance))\n                     ;; one double quote: end of quoted field\n                     ;; NOTE: we expect that a separator or newline is next, but\n                     ;; don't verify. Therefore, any characters between the\n                     ;; \"closing\" double quote and the next separator or newline\n                     ;; will be appended to the current field.\n                     (-> state (dissoc :in-quoted-field) (-advance)))\n                   ;; regular character in quoted field\n                   (-consume state))\n                 (cond\n                   ;; first char in field is a quote\n                   (and (= char \\\")\n                        (not field-buffer))\n                   (-> state (assoc :in-quoted-field true) (-advance))\n\n                   (= char separator)\n                   (-> state (-end-field) (-advance))\n\n                   (and (= char \\return)\n                        (= newline :cr+lf)\n                        (= (first chars) \\newline))\n                   (-> state (-end-row) (-advance) (-advance))\n\n                   (and (= char \\newline)\n                        (= newline :lf))\n                   (-> state (-end-row) (-advance))\n\n                   :else\n                   (-consume state))))))))\n"]}